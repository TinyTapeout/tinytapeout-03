/* Generated by Yosys 0.23 (git sha1 7ce5011c24b) */

module dratini0_fsk_modem_top(io_out, io_in);
  wire fsk_modem_clk;
  wire fsk_modem_cs_n;
  wire fsk_modem_data_in;
  wire fsk_modem_data_out;
  wire fsk_modem_mosi;
  wire fsk_modem_rst;
  wire fsk_modem_samples_in;
  wire [5:0] fsk_modem_samples_out;
  wire fsk_modem_sck;
  wire fsk_modem_valid_out;
  input [7:0] io_in;
  wire [7:0] io_in;
  output [7:0] io_out;
  wire [7:0] io_out;
  fsk_modem fsk_modem (
    .clk(fsk_modem_clk),
    .cs_n(fsk_modem_cs_n),
    .data_in(fsk_modem_data_in),
    .data_out(fsk_modem_data_out),
    .mosi(fsk_modem_mosi),
    .rst(fsk_modem_rst),
    .samples_in(fsk_modem_samples_in),
    .samples_out(fsk_modem_samples_out),
    .sck(fsk_modem_sck),
    .valid_out(fsk_modem_valid_out)
  );
  assign io_out[7:2] = fsk_modem_samples_out;
  assign io_out[1] = fsk_modem_valid_out;
  assign io_out[0] = fsk_modem_data_out;
  assign fsk_modem_samples_in = io_in[7];
  assign fsk_modem_data_in = io_in[5];
  assign fsk_modem_mosi = io_in[4];
  assign fsk_modem_sck = io_in[3];
  assign fsk_modem_cs_n = io_in[2];
  assign fsk_modem_rst = io_in[1];
  assign fsk_modem_clk = io_in[0];
endmodule

module fsk_modem(rst, cs_n, sck, mosi, data_in, samples_in, data_out, valid_out, samples_out, clk);
  wire [7:0] \$1 ;
  wire \$11 ;
  wire \$13 ;
  wire \$15 ;
  wire [13:0] \$3 ;
  wire [11:0] \$4 ;
  wire [13:0] \$7 ;
  wire [13:0] \$9 ;
  input clk;
  wire clk;
  input cs_n;
  wire cs_n;
  input data_in;
  wire data_in;
  output data_out;
  wire data_out;
  input mosi;
  wire mosi;
  wire [7:0] registers_data_in;
  wire registers_enforce_validity;
  wire registers_frequency_invert;
  wire [11:0] registers_mixer_freq;
  wire [7:0] registers_we;
  wire [11:0] registers_wg1_freq_mark;
  wire [11:0] registers_wg1_freq_space;
  wire [11:0] registers_wg2_freq;
  wire [1:0] registers_wg_mux_cfg;
  input rst;
  wire rst;
  wire [13:0] rx_frequency;
  wire rx_frequency_invert;
  wire rx_in_;
  wire rx_out;
  wire rx_valid;
  input samples_in;
  wire samples_in;
  output [5:0] samples_out;
  wire [5:0] samples_out;
  input sck;
  wire sck;
  wire spi_cs_n;
  wire [7:0] spi_data;
  wire spi_mosi;
  wire spi_sck;
  wire spi_we;
  output valid_out;
  wire valid_out;
  wire [13:0] wg1_frequency;
  wire [13:0] wg1_out;
  wire [13:0] wg2_frequency;
  wire [13:0] wg2_out;
  wire [1:0] wgmux_cfg;
  wire [9:0] wgmux_in1;
  wire [9:0] wgmux_in2;
  wire [9:0] wgmux_out;
  assign \$9  = + registers_mixer_freq;
  assign \$11  = ~ rx_valid;
  assign \$13  = registers_enforce_validity & \$11 ;
  assign \$15  = rx_out | \$13 ;
  assign \$1  = + spi_we;
  assign \$4  = data_in ? registers_wg1_freq_mark : registers_wg1_freq_space;
  assign \$3  = + \$4 ;
  assign \$7  = + registers_wg2_freq;
  registers registers (
    .clk(clk),
    .data_in(registers_data_in),
    .enforce_validity(registers_enforce_validity),
    .frequency_invert(registers_frequency_invert),
    .mixer_freq(registers_mixer_freq),
    .rst(rst),
    .we(registers_we),
    .wg1_freq_mark(registers_wg1_freq_mark),
    .wg1_freq_space(registers_wg1_freq_space),
    .wg2_freq(registers_wg2_freq),
    .wg_mux_cfg(registers_wg_mux_cfg)
  );
  rx rx (
    .clk(clk),
    .frequency(rx_frequency),
    .frequency_invert(rx_frequency_invert),
    .in_(rx_in_),
    .out(rx_out),
    .rst(rst),
    .valid(rx_valid)
  );
  spi spi (
    .clk(clk),
    .cs_n(spi_cs_n),
    .data(spi_data),
    .mosi(spi_mosi),
    .rst(rst),
    .sck(spi_sck),
    .we(spi_we)
  );
  wg1 wg1 (
    .clk(clk),
    .frequency(wg1_frequency),
    .out(wg1_out),
    .rst(rst)
  );
  wg2 wg2 (
    .clk(clk),
    .frequency(wg2_frequency),
    .out(wg2_out),
    .rst(rst)
  );
  wgmux wgmux (
    .cfg(wgmux_cfg),
    .in1(wgmux_in1),
    .in2(wgmux_in2),
    .out(wgmux_out)
  );
  assign valid_out = rx_valid;
  assign data_out = \$15 ;
  assign rx_frequency_invert = registers_frequency_invert;
  assign rx_frequency = \$9 ;
  assign rx_in_ = samples_in;
  assign samples_out = wgmux_out[9:4];
  assign wgmux_cfg = registers_wg_mux_cfg;
  assign wgmux_in2 = wg2_out[13:4];
  assign wgmux_in1 = wg1_out[13:4];
  assign wg2_frequency = \$7 ;
  assign wg1_frequency = \$3 ;
  assign registers_we = \$1 ;
  assign registers_data_in = spi_data;
  assign spi_mosi = mosi;
  assign spi_sck = sck;
  assign spi_cs_n = cs_n;
endmodule

module glitch_filter(rst, in_, out, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$1  = 0;
  wire \$1 ;
  wire \$10 ;
  wire \$3 ;
  wire [2:0] \$5 ;
  wire [2:0] \$6 ;
  wire \$8 ;
  reg [1:0] _count = 2'h0;
  reg [1:0] \_count$next ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  output out;
  reg out = 1'h0;
  reg \out$next ;
  input rst;
  wire rst;
  assign \$10  = _count == 2'h3;
  always @(posedge clk)
    _count <= \_count$next ;
  always @(posedge clk)
    out <= \out$next ;
  assign \$1  = in_ == out;
  assign \$3  = _count == 2'h3;
  assign \$6  = _count + 1'h1;
  assign \$8  = in_ == out;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    (* full_case = 32'd1 *)
    casez ({ \$3 , \$1  })
      2'b?1:
          \_count$next  = 2'h0;
      2'b1?:
          \_count$next  = 2'h0;
      default:
          \_count$next  = \$6 [1:0];
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    \out$next  = out;
    casez ({ \$10 , \$8  })
      2'b?1:
          /* empty */;
      2'b1?:
          \out$next  = in_;
    endcase
  end
  assign \$5  = \$6 ;
endmodule

module i_filter(rst, in_, out, clk);
  wire [31:0] \$1 ;
  wire [3:0] \$10 ;
  wire [26:0] \$100 ;
  wire [3:0] \$102 ;
  wire [27:0] \$104 ;
  wire [3:0] \$106 ;
  wire [28:0] \$108 ;
  wire [1:0] \$110 ;
  wire [29:0] \$112 ;
  wire [1:0] \$114 ;
  wire [30:0] \$116 ;
  wire [1:0] \$118 ;
  wire [4:0] \$12 ;
  wire [31:0] \$120 ;
  wire [3:0] \$14 ;
  wire [5:0] \$16 ;
  wire [3:0] \$18 ;
  wire [1:0] \$2 ;
  wire [6:0] \$20 ;
  wire [3:0] \$22 ;
  wire [7:0] \$24 ;
  wire [7:0] \$26 ;
  wire [8:0] \$28 ;
  wire [7:0] \$30 ;
  wire [9:0] \$32 ;
  wire [7:0] \$34 ;
  wire [10:0] \$36 ;
  wire [7:0] \$38 ;
  wire [2:0] \$4 ;
  wire [11:0] \$40 ;
  wire [7:0] \$42 ;
  wire [12:0] \$44 ;
  wire [7:0] \$46 ;
  wire [13:0] \$48 ;
  wire [7:0] \$50 ;
  wire [14:0] \$52 ;
  wire [7:0] \$54 ;
  wire [15:0] \$56 ;
  wire [7:0] \$58 ;
  wire [1:0] \$6 ;
  wire [16:0] \$60 ;
  wire [7:0] \$62 ;
  wire [17:0] \$64 ;
  wire [7:0] \$66 ;
  wire [18:0] \$68 ;
  wire [7:0] \$70 ;
  wire [19:0] \$72 ;
  wire [7:0] \$74 ;
  wire [20:0] \$76 ;
  wire [7:0] \$78 ;
  wire [3:0] \$8 ;
  wire [21:0] \$80 ;
  wire [7:0] \$82 ;
  wire [22:0] \$84 ;
  wire [7:0] \$86 ;
  wire [23:0] \$88 ;
  wire [7:0] \$90 ;
  wire [24:0] \$92 ;
  wire [3:0] \$94 ;
  wire [25:0] \$96 ;
  wire [3:0] \$98 ;
  reg [29:0] _x = 30'h00000000;
  wire [29:0] \_x$next ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  output [8:0] out;
  wire [8:0] out;
  input rst;
  wire rst;
  assign \$100  = \$96  + \$98 ;
  assign \$104  = \$100  + \$102 ;
  assign \$108  = \$104  + \$106 ;
  assign \$112  = \$108  + \$110 ;
  assign \$116  = \$112  + \$114 ;
  assign \$120  = \$116  + \$118 ;
  always @(posedge clk)
    _x <= \_x$next ;
  assign \$12  = \$8  + \$10 ;
  assign \$16  = \$12  + \$14 ;
  assign \$20  = \$16  + \$18 ;
  assign \$24  = \$20  + \$22 ;
  assign \$28  = \$24  + \$26 ;
  assign \$32  = \$28  + \$30 ;
  assign \$36  = \$32  + \$34 ;
  assign \$40  = \$36  + \$38 ;
  assign \$44  = \$40  + \$42 ;
  assign \$48  = \$44  + \$46 ;
  assign \$4  = in_ + \$2 ;
  assign \$52  = \$48  + \$50 ;
  assign \$56  = \$52  + \$54 ;
  assign \$60  = \$56  + \$58 ;
  assign \$64  = \$60  + \$62 ;
  assign \$68  = \$64  + \$66 ;
  assign \$72  = \$68  + \$70 ;
  assign \$76  = \$72  + \$74 ;
  assign \$80  = \$76  + \$78 ;
  assign \$84  = \$80  + \$82 ;
  assign \$88  = \$84  + \$86 ;
  assign \$8  = \$4  + \$6 ;
  assign \$92  = \$88  + \$90 ;
  assign \$96  = \$92  + \$94 ;
  assign \$1  = \$120 ;
  assign out = \$120 [8:0];
  assign \_x$next [29:1] = _x[28:0];
  assign \_x$next [0] = in_;
  assign \$2  = { 1'h0, _x[0] };
  assign \$6  = { _x[1], 1'h0 };
  assign \$10  = { 1'h0, _x[2], 2'h0 };
  assign \$14  = { 1'h0, _x[3], 2'h0 };
  assign \$18  = { _x[4], 3'h0 };
  assign \$22  = { _x[5], 3'h0 };
  assign \$26  = { 3'h0, _x[6], 4'h0 };
  assign \$30  = { 3'h0, _x[7], 4'h0 };
  assign \$34  = { 3'h0, _x[8], 4'h0 };
  assign \$38  = { 2'h0, _x[9], 5'h00 };
  assign \$42  = { 2'h0, _x[10], 5'h00 };
  assign \$46  = { 2'h0, _x[11], 5'h00 };
  assign \$50  = { 2'h0, _x[12], 5'h00 };
  assign \$54  = { 2'h0, _x[13], 5'h00 };
  assign \$58  = { 2'h0, _x[14], 5'h00 };
  assign \$62  = { 2'h0, _x[15], 5'h00 };
  assign \$66  = { 2'h0, _x[16], 5'h00 };
  assign \$70  = { 2'h0, _x[17], 5'h00 };
  assign \$74  = { 2'h0, _x[18], 5'h00 };
  assign \$78  = { 2'h0, _x[19], 5'h00 };
  assign \$82  = { 3'h0, _x[20], 4'h0 };
  assign \$86  = { 3'h0, _x[21], 4'h0 };
  assign \$90  = { 3'h0, _x[22], 4'h0 };
  assign \$94  = { _x[23], 3'h0 };
  assign \$98  = { _x[24], 3'h0 };
  assign \$102  = { 1'h0, _x[25], 2'h0 };
  assign \$106  = { 1'h0, _x[26], 2'h0 };
  assign \$110  = { _x[27], 1'h0 };
  assign \$114  = { 1'h0, _x[28] };
  assign \$118  = { 1'h0, _x[29] };
endmodule

module lut(out, in_);
  reg \$auto$verilog_backend.cc:2083:dump_module$2  = 0;
  wire \$1 ;
  wire [13:0] \$10 ;
  wire [14:0] \$13 ;
  wire [13:0] \$15 ;
  wire [14:0] \$17 ;
  wire \$19 ;
  wire \$21 ;
  wire [15:0] \$23 ;
  wire [15:0] \$24 ;
  wire [14:0] \$3 ;
  wire [13:0] \$4 ;
  wire [14:0] \$6 ;
  wire [14:0] \$8 ;
  wire [13:0] \$9 ;
  reg [13:0] _temp1;
  wire [14:0] _temp2;
  input [13:0] in_;
  wire [13:0] in_;
  output [13:0] out;
  reg [13:0] out;
  assign \$9  = ~ \$10 ;
  assign \$13  = \$9  - 14'h2000;
  assign \$17  = $signed(_temp1) + $signed(\$15 );
  assign \$1  = ~ in_[13];
  assign \$19  = $signed(_temp2) < $signed(14'h2000);
  assign \$21  = $signed(_temp2) >= $signed(15'h2000);
  assign \$24  = $signed(_temp2) + $signed(15'h2000);
  assign \$6  = \$4  - 14'h2000;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    (* full_case = 32'd1 *)
    casez (\$1 )
      1'h1:
          _temp1 = \$6 [13:0];
      default:
          _temp1 = \$13 [13:0];
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    (* full_case = 32'd1 *)
    casez ({ \$21 , \$19  })
      2'b?1:
          out = 14'h0000;
      2'b1?:
          out = 14'h3fff;
      default:
          out = \$24 [13:0];
    endcase
  end
  assign \$3  = \$6 ;
  assign \$8  = \$13 ;
  assign \$23  = \$24 ;
  assign _temp2 = \$17 ;
  assign \$4  = { in_[12:0], 1'h0 };
  assign \$10  = { in_[12:0], 1'h0 };
  assign \$15  = { _temp1[13], _temp1[13:1] };
endmodule

module \lut$1 (out, in_);
  reg \$auto$verilog_backend.cc:2083:dump_module$3  = 0;
  wire \$1 ;
  wire [13:0] \$10 ;
  wire [14:0] \$13 ;
  wire [13:0] \$15 ;
  wire [14:0] \$17 ;
  wire \$19 ;
  wire \$21 ;
  wire [15:0] \$23 ;
  wire [15:0] \$24 ;
  wire [14:0] \$3 ;
  wire [13:0] \$4 ;
  wire [14:0] \$6 ;
  wire [14:0] \$8 ;
  wire [13:0] \$9 ;
  reg [13:0] _temp1;
  wire [14:0] _temp2;
  input [13:0] in_;
  wire [13:0] in_;
  output [13:0] out;
  reg [13:0] out;
  assign \$9  = ~ \$10 ;
  assign \$13  = \$9  - 14'h2000;
  assign \$17  = $signed(_temp1) + $signed(\$15 );
  assign \$1  = ~ in_[13];
  assign \$19  = $signed(_temp2) < $signed(14'h2000);
  assign \$21  = $signed(_temp2) >= $signed(15'h2000);
  assign \$24  = $signed(_temp2) + $signed(15'h2000);
  assign \$6  = \$4  - 14'h2000;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    (* full_case = 32'd1 *)
    casez (\$1 )
      1'h1:
          _temp1 = \$6 [13:0];
      default:
          _temp1 = \$13 [13:0];
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    (* full_case = 32'd1 *)
    casez ({ \$21 , \$19  })
      2'b?1:
          out = 14'h0000;
      2'b1?:
          out = 14'h3fff;
      default:
          out = \$24 [13:0];
    endcase
  end
  assign \$3  = \$6 ;
  assign \$8  = \$13 ;
  assign \$23  = \$24 ;
  assign _temp2 = \$17 ;
  assign \$4  = { in_[12:0], 1'h0 };
  assign \$10  = { in_[12:0], 1'h0 };
  assign \$15  = { _temp1[13], _temp1[13:1] };
endmodule

module mixer(rst, in_, frequency, i, q, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$4  = 0;
  wire [14:0] \$1 ;
  wire \$10 ;
  wire [14:0] \$2 ;
  wire \$4 ;
  wire \$6 ;
  wire \$8 ;
  reg [13:0] _phase = 14'h0000;
  wire [13:0] \_phase$next ;
  input clk;
  wire clk;
  input [13:0] frequency;
  wire [13:0] frequency;
  output i;
  reg i;
  input in_;
  wire in_;
  output q;
  reg q;
  input rst;
  wire rst;
  assign \$10  = ~ $signed(in_);
  always @(posedge clk)
    _phase <= \_phase$next ;
  assign \$2  = _phase + frequency;
  assign \$4  = ~ $signed(in_);
  assign \$6  = ~ $signed(in_);
  assign \$8  = ~ $signed(in_);
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$4 ) begin end
    (* full_case = 32'd1 *)
    casez (_phase[13:12])
      2'h0:
          i = in_;
      2'h1:
          i = in_;
      2'h2:
          i = \$4 ;
      2'h3:
          i = \$6 ;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$4 ) begin end
    (* full_case = 32'd1 *)
    casez (_phase[13:12])
      2'h0:
          q = in_;
      2'h1:
          q = \$8 ;
      2'h2:
          q = \$10 ;
      2'h3:
          q = in_;
    endcase
  end
  assign \$1  = \$2 ;
  assign \_phase$next  = \$2 [13:0];
endmodule

module phase_detector(q, phase, i);
  reg \$auto$verilog_backend.cc:2083:dump_module$5  = 0;
  wire [9:0] \$1 ;
  wire \$10 ;
  wire \$13 ;
  wire \$15 ;
  wire \$17 ;
  wire [9:0] \$3 ;
  wire \$4 ;
  wire [9:0] \$7 ;
  wire [9:0] \$9 ;
  input [9:0] i;
  wire [9:0] i;
  output [2:0] phase;
  reg [2:0] phase;
  input [9:0] q;
  wire [9:0] q;
  assign \$10  = $signed(q) >= $signed(10'h000);
  assign \$9  = \$10  ? q : \$7 ;
  assign \$13  = $signed(\$3 ) > $signed(\$9 );
  assign \$15  = $signed(i) >= $signed(10'h000);
  assign \$17  = $signed(q) >= $signed(10'h000);
  assign \$1  = ~ $signed(i);
  assign \$4  = $signed(i) >= $signed(10'h000);
  assign \$3  = \$4  ? i : \$1 ;
  assign \$7  = ~ $signed(q);
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$5 ) begin end
    (* full_case = 32'd1 *)
    casez ({ \$17 , \$15 , \$13  })
      3'h7:
          phase = 3'h0;
      3'h6:
          phase = 3'h1;
      3'h4:
          phase = 3'h2;
      3'h5:
          phase = 3'h3;
      3'h1:
          phase = 3'h4;
      3'h0:
          phase = 3'h5;
      3'h2:
          phase = 3'h6;
      3'h3:
          phase = 3'h7;
    endcase
  end
endmodule

module phase_differentiator(rst, phase, out, valid, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$6  = 0;
  wire \$1 ;
  wire \$10 ;
  wire [10:0] \$12 ;
  wire [3:0] \$3 ;
  wire [3:0] \$4 ;
  wire [3:0] \$6 ;
  wire [3:0] \$7 ;
  wire [10:0] \$9 ;
  reg [2:0] _last_phase = 3'h0;
  wire [2:0] \_last_phase$next ;
  reg [9:0] _valid_counter = 10'h000;
  reg [9:0] \_valid_counter$next ;
  reg _valid_counter_reset;
  input clk;
  wire clk;
  output out;
  reg out = 1'h0;
  reg \out$next ;
  input [2:0] phase;
  wire [2:0] phase;
  input rst;
  wire rst;
  output valid;
  wire valid;
  assign \$10  = ~ valid;
  assign \$12  = _valid_counter + \$10 ;
  always @(posedge clk)
    _last_phase <= \_last_phase$next ;
  always @(posedge clk)
    out <= \out$next ;
  always @(posedge clk)
    _valid_counter <= \_valid_counter$next ;
  assign \$1  = _valid_counter == 10'h3ff;
  assign \$4  = phase - _last_phase;
  assign \$7  = phase - _last_phase;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    (* full_case = 32'd1 *)
    casez (\$3 [2:0])
      3'h0:
          _valid_counter_reset = 1'h0;
      3'h7:
          _valid_counter_reset = 1'h0;
      3'h1:
          _valid_counter_reset = 1'h0;
      default:
          _valid_counter_reset = 1'h1;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    \out$next  = out;
    casez (\$6 [2:0])
      3'h0:
          /* empty */;
      3'h7:
          \out$next  = 1'h1;
      3'h1:
          \out$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    (* full_case = 32'd1 *)
    casez (_valid_counter_reset)
      1'h1:
          \_valid_counter$next  = 10'h000;
      default:
          \_valid_counter$next  = \$12 [9:0];
    endcase
  end
  assign \$3  = \$4 ;
  assign \$6  = \$7 ;
  assign \$9  = \$12 ;
  assign \_last_phase$next  = phase;
  assign valid = \$1 ;
endmodule

module q_filter(rst, in_, out, clk);
  wire [31:0] \$1 ;
  wire [3:0] \$10 ;
  wire [26:0] \$100 ;
  wire [3:0] \$102 ;
  wire [27:0] \$104 ;
  wire [3:0] \$106 ;
  wire [28:0] \$108 ;
  wire [1:0] \$110 ;
  wire [29:0] \$112 ;
  wire [1:0] \$114 ;
  wire [30:0] \$116 ;
  wire [1:0] \$118 ;
  wire [4:0] \$12 ;
  wire [31:0] \$120 ;
  wire [3:0] \$14 ;
  wire [5:0] \$16 ;
  wire [3:0] \$18 ;
  wire [1:0] \$2 ;
  wire [6:0] \$20 ;
  wire [3:0] \$22 ;
  wire [7:0] \$24 ;
  wire [7:0] \$26 ;
  wire [8:0] \$28 ;
  wire [7:0] \$30 ;
  wire [9:0] \$32 ;
  wire [7:0] \$34 ;
  wire [10:0] \$36 ;
  wire [7:0] \$38 ;
  wire [2:0] \$4 ;
  wire [11:0] \$40 ;
  wire [7:0] \$42 ;
  wire [12:0] \$44 ;
  wire [7:0] \$46 ;
  wire [13:0] \$48 ;
  wire [7:0] \$50 ;
  wire [14:0] \$52 ;
  wire [7:0] \$54 ;
  wire [15:0] \$56 ;
  wire [7:0] \$58 ;
  wire [1:0] \$6 ;
  wire [16:0] \$60 ;
  wire [7:0] \$62 ;
  wire [17:0] \$64 ;
  wire [7:0] \$66 ;
  wire [18:0] \$68 ;
  wire [7:0] \$70 ;
  wire [19:0] \$72 ;
  wire [7:0] \$74 ;
  wire [20:0] \$76 ;
  wire [7:0] \$78 ;
  wire [3:0] \$8 ;
  wire [21:0] \$80 ;
  wire [7:0] \$82 ;
  wire [22:0] \$84 ;
  wire [7:0] \$86 ;
  wire [23:0] \$88 ;
  wire [7:0] \$90 ;
  wire [24:0] \$92 ;
  wire [3:0] \$94 ;
  wire [25:0] \$96 ;
  wire [3:0] \$98 ;
  reg [29:0] _x = 30'h00000000;
  wire [29:0] \_x$next ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  output [8:0] out;
  wire [8:0] out;
  input rst;
  wire rst;
  assign \$100  = \$96  + \$98 ;
  assign \$104  = \$100  + \$102 ;
  assign \$108  = \$104  + \$106 ;
  assign \$112  = \$108  + \$110 ;
  assign \$116  = \$112  + \$114 ;
  assign \$120  = \$116  + \$118 ;
  always @(posedge clk)
    _x <= \_x$next ;
  assign \$12  = \$8  + \$10 ;
  assign \$16  = \$12  + \$14 ;
  assign \$20  = \$16  + \$18 ;
  assign \$24  = \$20  + \$22 ;
  assign \$28  = \$24  + \$26 ;
  assign \$32  = \$28  + \$30 ;
  assign \$36  = \$32  + \$34 ;
  assign \$40  = \$36  + \$38 ;
  assign \$44  = \$40  + \$42 ;
  assign \$48  = \$44  + \$46 ;
  assign \$4  = in_ + \$2 ;
  assign \$52  = \$48  + \$50 ;
  assign \$56  = \$52  + \$54 ;
  assign \$60  = \$56  + \$58 ;
  assign \$64  = \$60  + \$62 ;
  assign \$68  = \$64  + \$66 ;
  assign \$72  = \$68  + \$70 ;
  assign \$76  = \$72  + \$74 ;
  assign \$80  = \$76  + \$78 ;
  assign \$84  = \$80  + \$82 ;
  assign \$88  = \$84  + \$86 ;
  assign \$8  = \$4  + \$6 ;
  assign \$92  = \$88  + \$90 ;
  assign \$96  = \$92  + \$94 ;
  assign \$1  = \$120 ;
  assign out = \$120 [8:0];
  assign \_x$next [29:1] = _x[28:0];
  assign \_x$next [0] = in_;
  assign \$2  = { 1'h0, _x[0] };
  assign \$6  = { _x[1], 1'h0 };
  assign \$10  = { 1'h0, _x[2], 2'h0 };
  assign \$14  = { 1'h0, _x[3], 2'h0 };
  assign \$18  = { _x[4], 3'h0 };
  assign \$22  = { _x[5], 3'h0 };
  assign \$26  = { 3'h0, _x[6], 4'h0 };
  assign \$30  = { 3'h0, _x[7], 4'h0 };
  assign \$34  = { 3'h0, _x[8], 4'h0 };
  assign \$38  = { 2'h0, _x[9], 5'h00 };
  assign \$42  = { 2'h0, _x[10], 5'h00 };
  assign \$46  = { 2'h0, _x[11], 5'h00 };
  assign \$50  = { 2'h0, _x[12], 5'h00 };
  assign \$54  = { 2'h0, _x[13], 5'h00 };
  assign \$58  = { 2'h0, _x[14], 5'h00 };
  assign \$62  = { 2'h0, _x[15], 5'h00 };
  assign \$66  = { 2'h0, _x[16], 5'h00 };
  assign \$70  = { 2'h0, _x[17], 5'h00 };
  assign \$74  = { 2'h0, _x[18], 5'h00 };
  assign \$78  = { 2'h0, _x[19], 5'h00 };
  assign \$82  = { 3'h0, _x[20], 4'h0 };
  assign \$86  = { 3'h0, _x[21], 4'h0 };
  assign \$90  = { 3'h0, _x[22], 4'h0 };
  assign \$94  = { _x[23], 3'h0 };
  assign \$98  = { _x[24], 3'h0 };
  assign \$102  = { 1'h0, _x[25], 2'h0 };
  assign \$106  = { 1'h0, _x[26], 2'h0 };
  assign \$110  = { _x[27], 1'h0 };
  assign \$114  = { 1'h0, _x[28] };
  assign \$118  = { 1'h0, _x[29] };
endmodule

module registers(rst, data_in, we, wg1_freq_mark, wg1_freq_space, wg2_freq, wg_mux_cfg, mixer_freq, frequency_invert, enforce_validity, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$7  = 0;
  wire \$1 ;
  wire \$11 ;
  wire \$13 ;
  wire \$3 ;
  wire \$5 ;
  wire \$7 ;
  wire \$9 ;
  input clk;
  wire clk;
  input [7:0] data_in;
  wire [7:0] data_in;
  output enforce_validity;
  reg enforce_validity = 1'h0;
  reg \enforce_validity$next ;
  output frequency_invert;
  reg frequency_invert = 1'h0;
  reg \frequency_invert$next ;
  output [11:0] mixer_freq;
  reg [11:0] mixer_freq = 12'h000;
  reg [11:0] \mixer_freq$next ;
  input rst;
  wire rst;
  input [7:0] we;
  wire [7:0] we;
  output [11:0] wg1_freq_mark;
  reg [11:0] wg1_freq_mark = 12'h000;
  reg [11:0] \wg1_freq_mark$next ;
  output [11:0] wg1_freq_space;
  reg [11:0] wg1_freq_space = 12'h000;
  reg [11:0] \wg1_freq_space$next ;
  output [11:0] wg2_freq;
  reg [11:0] wg2_freq = 12'h000;
  reg [11:0] \wg2_freq$next ;
  output [1:0] wg_mux_cfg;
  reg [1:0] wg_mux_cfg = 2'h0;
  reg [1:0] \wg_mux_cfg$next ;
  assign \$9  = | we;
  assign \$11  = | we;
  assign \$13  = | we;
  always @(posedge clk)
    wg1_freq_space <= \wg1_freq_space$next ;
  always @(posedge clk)
    wg1_freq_mark <= \wg1_freq_mark$next ;
  always @(posedge clk)
    wg2_freq <= \wg2_freq$next ;
  always @(posedge clk)
    wg_mux_cfg <= \wg_mux_cfg$next ;
  always @(posedge clk)
    mixer_freq <= \mixer_freq$next ;
  assign \$1  = | we;
  always @(posedge clk)
    frequency_invert <= \frequency_invert$next ;
  always @(posedge clk)
    enforce_validity <= \enforce_validity$next ;
  assign \$3  = | we;
  assign \$5  = | we;
  assign \$7  = | we;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \wg1_freq_space$next  = wg1_freq_space;
    casez (\$1 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                \wg1_freq_space$next [3:0] = data_in[3:0];
            4'h1:
                \wg1_freq_space$next [7:4] = data_in[3:0];
            4'h2:
                \wg1_freq_space$next [11:8] = data_in[3:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \wg1_freq_mark$next  = wg1_freq_mark;
    casez (\$3 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                \wg1_freq_mark$next [3:0] = data_in[3:0];
            4'h4:
                \wg1_freq_mark$next [7:4] = data_in[3:0];
            4'h5:
                \wg1_freq_mark$next [11:8] = data_in[3:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \wg2_freq$next  = wg2_freq;
    casez (\$5 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                \wg2_freq$next [3:0] = data_in[3:0];
            4'h7:
                \wg2_freq$next [7:4] = data_in[3:0];
            4'h8:
                \wg2_freq$next [11:8] = data_in[3:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \wg_mux_cfg$next  = wg_mux_cfg;
    casez (\$7 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                /* empty */;
            4'h7:
                /* empty */;
            4'h8:
                /* empty */;
            4'h9:
                \wg_mux_cfg$next  = data_in[1:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \mixer_freq$next  = mixer_freq;
    casez (\$9 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                /* empty */;
            4'h7:
                /* empty */;
            4'h8:
                /* empty */;
            4'h9:
                /* empty */;
            4'ha:
                \mixer_freq$next [3:0] = data_in[3:0];
            4'hb:
                \mixer_freq$next [7:4] = data_in[3:0];
            4'hc:
                \mixer_freq$next [11:8] = data_in[3:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \frequency_invert$next  = frequency_invert;
    casez (\$11 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                /* empty */;
            4'h7:
                /* empty */;
            4'h8:
                /* empty */;
            4'h9:
                /* empty */;
            4'ha:
                /* empty */;
            4'hb:
                /* empty */;
            4'hc:
                /* empty */;
            4'hd:
                \frequency_invert$next  = data_in[0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \enforce_validity$next  = enforce_validity;
    casez (\$13 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                /* empty */;
            4'h7:
                /* empty */;
            4'h8:
                /* empty */;
            4'h9:
                /* empty */;
            4'ha:
                /* empty */;
            4'hb:
                /* empty */;
            4'hc:
                /* empty */;
            4'hd:
                \enforce_validity$next  = data_in[1];
          endcase
    endcase
  end
endmodule

module rx(rst, in_, frequency, frequency_invert, out, valid, clk);
  wire [9:0] \$1 ;
  wire [9:0] \$3 ;
  wire \$5 ;
  input clk;
  wire clk;
  input [13:0] frequency;
  wire [13:0] frequency;
  input frequency_invert;
  wire frequency_invert;
  wire glitch_filter_in_;
  wire glitch_filter_out;
  wire i_filter_in_;
  wire [8:0] i_filter_out;
  input in_;
  wire in_;
  wire [13:0] mixer_frequency;
  wire mixer_i;
  wire mixer_in_;
  wire mixer_q;
  output out;
  wire out;
  wire [9:0] phase_detector_i;
  wire [2:0] phase_detector_phase;
  wire [9:0] phase_detector_q;
  wire phase_differentiator_out;
  wire [2:0] phase_differentiator_phase;
  wire phase_differentiator_valid;
  wire q_filter_in_;
  wire [8:0] q_filter_out;
  input rst;
  wire rst;
  output valid;
  wire valid;
  assign \$1  = i_filter_out - 8'hfc;
  assign \$3  = q_filter_out - 8'hfc;
  assign \$5  = glitch_filter_out ^ frequency_invert;
  glitch_filter glitch_filter (
    .clk(clk),
    .in_(glitch_filter_in_),
    .out(glitch_filter_out),
    .rst(rst)
  );
  i_filter i_filter (
    .clk(clk),
    .in_(i_filter_in_),
    .out(i_filter_out),
    .rst(rst)
  );
  mixer mixer (
    .clk(clk),
    .frequency(mixer_frequency),
    .i(mixer_i),
    .in_(mixer_in_),
    .q(mixer_q),
    .rst(rst)
  );
  phase_detector phase_detector (
    .i(phase_detector_i),
    .phase(phase_detector_phase),
    .q(phase_detector_q)
  );
  phase_differentiator phase_differentiator (
    .clk(clk),
    .out(phase_differentiator_out),
    .phase(phase_differentiator_phase),
    .rst(rst),
    .valid(phase_differentiator_valid)
  );
  q_filter q_filter (
    .clk(clk),
    .in_(q_filter_in_),
    .out(q_filter_out),
    .rst(rst)
  );
  assign valid = phase_differentiator_valid;
  assign out = \$5 ;
  assign glitch_filter_in_ = phase_differentiator_out;
  assign phase_differentiator_phase = phase_detector_phase;
  assign phase_detector_q = \$3 ;
  assign phase_detector_i = \$1 ;
  assign q_filter_in_ = mixer_q;
  assign i_filter_in_ = mixer_i;
  assign mixer_frequency = frequency;
  assign mixer_in_ = in_;
endmodule

module sck_edge(rst, in_, out, clk);
  wire \$1 ;
  wire \$3 ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  reg last_in = 1'h0;
  wire \last_in$next ;
  output out;
  wire out;
  input rst;
  wire rst;
  assign \$1  = ~ last_in;
  assign \$3  = in_ & \$1 ;
  always @(posedge clk)
    last_in <= \last_in$next ;
  assign out = \$3 ;
  assign \last_in$next  = in_;
endmodule

module spi(rst, cs_n, sck, mosi, data, we, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$8  = 0;
  wire \$1 ;
  wire \$12 ;
  wire \$14 ;
  wire [9:0] \$16 ;
  wire [9:0] \$17 ;
  wire \$19 ;
  wire \$21 ;
  wire \$23 ;
  wire \$25 ;
  wire \$3 ;
  wire [3:0] \$5 ;
  wire [3:0] \$6 ;
  wire \$8 ;
  wire \$9 ;
  reg [2:0] _bit_index = 3'h0;
  reg [2:0] \_bit_index$next ;
  input clk;
  wire clk;
  input cs_n;
  wire cs_n;
  output [7:0] data;
  reg [7:0] data = 8'h00;
  reg [7:0] \data$next ;
  input mosi;
  wire mosi;
  input rst;
  wire rst;
  input sck;
  wire sck;
  wire sck_edge_in_;
  wire sck_edge_out;
  output we;
  reg we = 1'h0;
  wire \we$next ;
  assign \$9  = ~ cs_n;
  assign \$12  = ~ cs_n;
  assign \$14  = \$12  & sck_edge_out;
  assign \$17  = { data, 1'h0 } + mosi;
  assign \$1  = ~ cs_n;
  assign \$19  = ~ cs_n;
  assign \$21  = \$19  & sck_edge_out;
  assign \$23  = _bit_index == 3'h7;
  assign \$25  = \$21  & \$23 ;
  always @(posedge clk)
    _bit_index <= \_bit_index$next ;
  always @(posedge clk)
    data <= \data$next ;
  always @(posedge clk)
    we <= \we$next ;
  assign \$3  = \$1  & sck_edge_out;
  assign \$6  = _bit_index + 1'h1;
  sck_edge sck_edge (
    .clk(clk),
    .in_(sck_edge_in_),
    .out(sck_edge_out),
    .rst(rst)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$8 ) begin end
    \_bit_index$next  = _bit_index;
    casez (\$3 )
      1'h1:
          \_bit_index$next  = \$6 [2:0];
    endcase
    casez (\$8 )
      1'h1:
          \_bit_index$next  = 3'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$8 ) begin end
    \data$next  = data;
    casez (\$14 )
      1'h1:
          \data$next  = \$17 [7:0];
    endcase
  end
  assign \$5  = \$6 ;
  assign \$16  = \$17 ;
  assign \we$next  = \$25 ;
  assign sck_edge_in_ = sck;
  assign \$8  = cs_n;
endmodule

module wg1(rst, frequency, out, clk);
  wire [14:0] \$1 ;
  wire [14:0] \$2 ;
  reg [13:0] _state = 14'h0000;
  wire [13:0] \_state$next ;
  input clk;
  wire clk;
  input [13:0] frequency;
  wire [13:0] frequency;
  wire [13:0] lut_in_;
  wire [13:0] lut_out;
  output [13:0] out;
  wire [13:0] out;
  input rst;
  wire rst;
  assign \$2  = _state + frequency;
  always @(posedge clk)
    _state <= \_state$next ;
  lut lut (
    .in_(lut_in_),
    .out(lut_out)
  );
  assign \$1  = \$2 ;
  assign \_state$next  = \$2 [13:0];
  assign out = lut_out;
  assign lut_in_ = _state;
endmodule

module wg2(rst, frequency, out, clk);
  wire [14:0] \$1 ;
  wire [14:0] \$2 ;
  reg [13:0] _state = 14'h0000;
  wire [13:0] \_state$next ;
  input clk;
  wire clk;
  input [13:0] frequency;
  wire [13:0] frequency;
  wire [13:0] lut_in_;
  wire [13:0] lut_out;
  output [13:0] out;
  wire [13:0] out;
  input rst;
  wire rst;
  assign \$2  = _state + frequency;
  always @(posedge clk)
    _state <= \_state$next ;
  \lut$1  lut (
    .in_(lut_in_),
    .out(lut_out)
  );
  assign \$1  = \$2 ;
  assign \_state$next  = \$2 [13:0];
  assign out = lut_out;
  assign lut_in_ = _state;
endmodule

module wgmux(in2, cfg, out, in1);
  reg \$auto$verilog_backend.cc:2083:dump_module$9  = 0;
  wire [10:0] \$1 ;
  wire [10:0] \$2 ;
  wire [10:0] \$4 ;
  input [1:0] cfg;
  wire [1:0] cfg;
  input [9:0] in1;
  wire [9:0] in1;
  input [9:0] in2;
  wire [9:0] in2;
  output [9:0] out;
  reg [9:0] out;
  assign \$2  = in1 + in2;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$9 ) begin end
    out = 10'h000;
    casez (cfg)
      2'h0:
        begin
          out[8:0] = 9'h000;
          out[9] = 1'h1;
        end
      2'h1:
          out = in1;
      2'h2:
          out = \$4 [9:0];
    endcase
  end
  assign \$1  = \$4 ;
  assign \$4  = { 1'h0, \$2 [10:1] };
endmodule

